# Snippets for Go

priority -50

# when to abbriviate and when not?
# b doesn't work here, because it ignores whitespace
# optional local name?
snippet /^import/ "Import declaration" r
import (
	"${1:package}"
)
endsnippet

snippet /^package/ "Package declaration" r
// Package $1 provides ...
package ${1:main}
endsnippet

# Mostly converted from: https://github.com/AlanQuatermain/go-tmbundle
snippet /^cons/ "Constants declaration" r
const (
	${1:constant}${2/(.+)/ /}${2:type} = ${0:value}
)
endsnippet

snippet /^con/ "Constant declaration" r
const ${1:name}${2/(.+)/ /}${2:type} = ${0:value}
endsnippet

snippet iota "Iota constant generator" b
const (
	${1:constant}${2/(.+)/ /}${2:type} = iota
)
endsnippet

snippet struct "Struct declaration" b
type ${1:Struct} struct {
	${0:${VISUAL}}
}
endsnippet

snippet interface "Interface declaration" b
type ${1:Interface} interface {
	${0:${VISUAL}}
}
endsnippet

snippet if "If statement" b
if ${1:condition}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet switch "Switch statement" b
switch ${1:expression}${1/(.+)/ /}{
case$0
}
endsnippet

# functions
snippet /^main/ "Main function" r
func main() {
	${0:${VISUAL}}
}
endsnippet

snippet /^meth/ "Method" r
func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}${5:type} {
	${0:${VISUAL}}
}
endsnippet

snippet func "Function" b
// ${4:commit}
func ${1:name}(${2:params})${3/(.+)/ /}${3:type} {
	${0:${VISUAL}}
}
endsnippet

snippet funch "HTTP handler" b
// ${11:commit}
func ${1:HandleName}(w http.ResponseWriter, r *http.Request) {
	sp := rest.GetRequestTraceSpan("$1", r)
	defer sp.Finish()
	ctx := opentracing.ContextWithSpan(r.Context(), sp)
	r = r.WithContext(ctx)
	h := rest.GetCtxParams(r)
	vars    := mux.Vars(r)
	${0:${VISUAL}}
	// path
	${2:cityId}, err := strconv.ParseInt(vars["${3:city_id}"], 10, 64)
	if err != nil {
		logger.Warn(h.RequestID, "参数 $3 有误, err=", err.Error())
		rest.ToFailedJSON(w, h, common.ERR0006, common.GetInvalidParmErr(h))
		return
	}

	// query
	${4:queryStr} := r.FormValue("${5:queryStr}")
	${6:queryInt}, err := strconv.ParseInt(r.FormValue("${7:queryInt}"), 10, 64)
	if err != nil {
		logger.Warn(h.RequestID, "参数 $6 有误, err=", err.Error())
		rest.ToFailedJSON(w, h, common.ERR0006, common.GetInvalidParmErr(h))
		return
	}

	// header
	// language := h.Lang

	if resp, err := ${8:Name}(ctx, h, ${9:params}); err != nil {
		logger.Warn(h.RequestID, "${10:msg} 出错, err=", err.Error())
		rest.ToFailedJSON(w, h, comm.ERR0001, "Failed to $10")
		return
	} else {
		rest.ToJSON(w, h, resp)
	}
}
endsnippet

# types and variables
snippet map "Map type" b
map[${1:keytype}]${2:valtype}
endsnippet

snippet : "Variable declaration :=" b
${1:name} := ${0:value}
endsnippet

snippet var "Variable declaration" b
var ${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value}}
endsnippet

snippet vars "Variables declaration" b
var (
	${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value} }
)
endsnippet

snippet json "JSON field"
\`json:"${1:displayName}"\`
endsnippet

# vim:ft=snippets:

# error handling
snippet err "Basic error handling" b
if err != nil {
	log.${1:Fatal}(err)
}
endsnippet


# redis
snippet cc "redisGetSetV3" b
	${0:${VISUAL}}libsrdb "klook.libs/db/redisdb"
	var (
		response = ${1:responseType}
		cacheKey = fmt.Sprintf("%s:${4:cacheKey}", redisdb${5:.CacheTagName}, ${6:cacheKeyParams})
		err error
	)

	f := func(timeout bool) error {
		if timeout {
			return nil
		}
		// get from cache
		if err = redisdb.Get(cacheKey, &response); err != nil {
			// query from http
			if response, err = ${2:funbyDB}(ctx, ${3:params}); err != nil {
				return err
			}

			// save to cache
			if err = redisdb.Set(cacheKey, response, redisdb${7:.DefaultExpiresTime}); err != nil {
				logger.Errorf("%s key:%s err:%s", utils.RequestIDFromContext(ctx), cacheKey, err)
			}
		}

		return nil
	}

	// 加锁更新redis缓存，避免缓存失效对mysql造成冲击
	// 	libsrdb "klook.libs/db/redisdb"
	return response, libsrdb.NewRedislock(redisdb.CacheDB, redisdb.LockExpireTime, redisdb.LockTries, redisdb.LockDelayTime).GetSetV3(cacheKey, f)
endsnippet

# Fmt Sprintf
snippet fsf "fmt.Sprintf(...)"
fmt.Sprintf("${1:${VISUAL}}: %+v\n", $1)
endsnippet

# Fmt Println debug
snippet fsn "fmt.Sprintln(...)"
fmt.Sprintln("${1:${VISUAL}}")
endsnippet

snippet funck "Function ctx" b
// ${6:commit}
func ${1:name}(ctx context.Context, h *comm.HandlerInfo, ${4:params} ${5:paramsType}) (${2:returnType}, error) {
	sp, ctx := opentracing.StartSpanFromContext(ctx, "$1")
	defer sp.Finish()

	var (
		${3:ret} $2
		err error
	)

	${0:${VISUAL}}
	return $3, err
}
endsnippet

# RealLang
snippet lang "language"
language ${1::}= prolocale.RealLang(${2:h.Lang})
${VISUAL}
endsnippet

# sqlx
snippet tx "sqlx.Tx"
tx, err := ${1:projectkdb.ProKDB}.Beginx()
if err != nil {
	return ${2:err}
}
defer tx.Rollback()
${VISUAL}
if err := ${3:smsdb.InsertUserFraud}(${4:ctx}, ${5:tx}, ${6:userFraud}); err != nil {
	return $2
}
return ${7:tx.Commit()}
endsnippet

# tracing
snippet spt "opentracing"
sp, ctx := opentracing.StartSpanFromContext(ctx, "${1:QueryEmailAndIP}")
defer sp.Finish()
${VISUAL}
endsnippet

# post body
snippet postbody "postunmasrshal"
req := ${1:smsConfirmRequest}{}
if err := utils.ParseBodyAndUnmarshal(r, &${2:req}); err != nil {
	logger.Error(${3:h}.RequestID, " 解析出错, err:", err.Error())
	rest.ToFailedJSON(w, $3, comm.ERR0006, ${5:fmt.Sprintf("[%s] %s", $3.RequestID, "${4:parameters err}")})
	return
}
${VISUAL}
endsnippet

# append
snippet app "append"
${1:list} = append($1, ${2:item})
${VISUAL}
endsnippet

# timeAdd
snippet timeadd "time.Add"
// 一天后
${1:startTime} := time.Now()${2:.UTC().}AddDate(0, 0, ${5:1}).Format(${3:utils.TsFormat1})
${4:endTime} := time.Now().UTC().Format($3)
${VISUAL}
// 北京时间 12小时前
$1 := time.Now()$2Add(${6:8} * time.Hour).Add(${7:-12} * time.Hour).Format($3)
// 北京时间, utc 8小时后
$4 := time.Now()$2Add($6 * time.Hour).Format($3)
endsnippet

snippet sqlx "sqlx.In"
querySql, args, err := sqlx.In(querySql, ${1:lang, actIDs})
if err != nil {
	return nil, err
}
var ${2:data} = make([]*${3:Category}, 0)
// productdb.ReadDB, projectkdb.LibsMyDB.GetSqlxDB()
if err := ${4:productdb.ReadDB}.SelectContext(ctx, &${2}, querySql, args...); err != nil {
	return nil, err
}
${VISUAL}
endsnippet

snippet geturl ""
var ${1:data} = ${2:make([]*CityNews, 0)}
queryURL := fmt.Sprintf("%s${3:/v1/prodbasesrv/city/%d/basic_info}", ${4:conf.Conf.ProdBaseHost} ${5:, cityId})
// 基础服务 prorest, 三端共用服 apprest
if err := ${6:apprest}.GetAndParseResult(ctx, h, queryURL, $1); err != nil {
	logger.Errorf("%s [${7:GetCityTravelTipsByDB}] ${8:get basic_info} err:%s", h.RequestID, ${9: }err.Error())
	return ${10:nil, err}
}
${VISUAL}
endsnippet

snippet posturl ""
${1:var req nearbyRequest}
var ${2:resp} ${3:prodbaseQueryResponse}
queryURL := fmt.Sprintf("%s${4:/v1/prodbasesrv/fnb/nearby}", ${4:conf.Conf.ProdBaseHost} ${6:, params})
// 基础服务 prorest, 三端共用服 apprest
if err := ${7:apprest}.PostAndParseResult(ctx, h, queryURL, $8, &$2); err != nil {
	logger.Errorf("%s [${9:GetCityTravelTipsByDB}] ${10:get basic_info} err:%s", h.RequestID, ${11: }err.Error())
	return ${12:nil, err}
}
${VISUAL}
endsnippet
