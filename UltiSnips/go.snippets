# Snippets for Go

priority -50

# when to abbriviate and when not?
# b doesn't work here, because it ignores whitespace
# optional local name?
snippet /^import/ "Import declaration" r
import (
	"${1:package}"
)
endsnippet

snippet /^package/ "Package declaration" r
// Package $1 provides ...
package ${1:main}
endsnippet

# Mostly converted from: https://github.com/AlanQuatermain/go-tmbundle
snippet /^cons/ "Constants declaration" r
const (
	${1:constant}${2/(.+)/ /}${2:type} = ${0:value}
)
endsnippet

snippet /^con/ "Constant declaration" r
const ${1:name}${2/(.+)/ /}${2:type} = ${0:value}
endsnippet

snippet iota "Iota constant generator" b
const (
	${1:constant}${2/(.+)/ /}${2:type} = iota
)
endsnippet

snippet struct "Struct declaration" b
type ${1:Struct} struct {
	${0:${VISUAL}}
}
endsnippet

snippet interface "Interface declaration" b
type ${1:Interface} interface {
	${0:${VISUAL}}
}
endsnippet

snippet inter "Interface declaration" b
type ${1:Interface} interface {
	${0:${VISUAL}}
}
endsnippet

snippet if "If statement" b
if ${1:condition}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet switch "Switch statement" b
switch ${1:expression}${1/(.+)/ /}{
case$0
}
endsnippet

snippet : "Variable declaration :=" b
${1:name} := ${0:value}
endsnippet

snippet var "Variable declaration" b
var ${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value}}
endsnippet

snippet vars "Variables declaration" b
var (
	${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value} }
)
endsnippet

snippet json "JSON field"
\`json:"${1:displayName}"\`
endsnippet

snippet jsonomi "JSON omitempty"
omitempty
endsnippet

# 美化 字符串json
snippet jsonpretty "JSON pretty"
var ${1:out} bytes.Buffer
err := json.Indent(&$1, []byte(${2:resp}), "", "\t")
if err != nil {
	logger.Debugf("[##########] err:%#v", err)
}else{
	${3:prettyJson} := $1.String()
	logger.Debugf("[##########] $2:%s\n", $3)
}
endsnippet


snippet schema "schema field"
\`schema:"${1:displayName}"\`
endsnippet

# vim:ft=snippets:

# error handling
snippet err "Basic error handling" b
if err != nil {
	logger.Errorf("%s [${1:%s}] ${2:get basic_info} err:%v", ${3:utils.RequestIDFromContext(ctx)}, ${4:funcName}, err)
}
endsnippet

# error handling
snippet errnew "new error"
fmt.Errorf("%s [${1:%s}] ${2:get basic_info} err:%v", ${3:utils.RequestIDFromContext(ctx)}, ${4:funcName}, err)
endsnippet


# redis
snippet cc "redisGetSetV3" b
	${0:${VISUAL}}libsrdb "klook.libs/db/redisdb"
	var (
		response = ${1:responseType}
		cacheKey = fmt.Sprintf("%s:${4:cacheKey}", redisdb${5:.CacheTagName}, ${6:cacheKeyParams})
		err error
	)

	f := func(timeout bool) error {
		if timeout {
			return nil
		}
		// get from cache
		if err = redisdb.Get(cacheKey, &response); err != nil {
			// query from http
			if response, err = ${2:funbyDB}(ctx, ${3:params}); err != nil {
				return err
			}
			// save to cache
			if err = redisdb.Set(cacheKey, response, redisdb${7:.DefaultExpiresTime}); err != nil {
				logger.Errorf("%s key:%s err:%s", utils.RequestIDFromContext(ctx), cacheKey, err)
			}
		}
		return nil
	}
	// 加锁更新redis缓存，避免缓存失效对mysql造成冲击
	// 	libsrdb "klook.libs/db/redisdb"
	return response, libsrdb.NewRedislock(redisdb.CacheDB, redisdb.LockExpireTime, redisdb.LockTries, redisdb.LockDelayTime).GetSetV3(cacheKey, f)
endsnippet

# Fmt Sprintf
snippet fsf "fmt.Sprintf(...)"
fmt.Sprintf("${1:${VISUAL}}: %+v\n", $1)
endsnippet

# Fmt Println debug
snippet fsn "fmt.Sprintln(...)"
fmt.Sprintln("${1:${VISUAL}}")
endsnippet

# Fmt Println debug
snippet fmtmp "fmt.Printf(...)"
fmt.Printf("############## $1:%#v \n", ${1:v})
endsnippet

# RealLang
snippet lang "language"
${3:lang} ${1::}= prolocale.RealLang(${2:h.Lang})
${0:${VISUAL}}
endsnippet

# append
snippet app "append"
${1:list} = append($1, ${2:item})
endsnippet

#################### 时间
# timeAdd
snippet timeadd "time.Add"
// 一天后
${1:startTime} := time.Now()${2:.UTC().}AddDate(0, 0, ${5:1}).Format(${3:utils.TsFormat1})
${4:endTime} := time.Now().UTC().Format($3)
${0:${VISUAL}}
// 北京时间 12小时前
$1 := time.Now()$2Add(${6:8} * time.Hour).Add(${7:-12} * time.Hour).Format($3)
// 北京时间, utc 8小时后
$4 := time.Now()$2Add($6 * time.Hour).Format($3)
endsnippet

snippet timefmt "time.Parse"
${0:${VISUAL}}
var ${1:timeStrTo} string
if ${2:tt}, err := time.Parse("${3:2006-01-02 15:04:05}", ${4:timeStrFrom}); err == nil {
	$1 = $2.Format("${5:2006-01-02T15:04:05Z}")
}
endsnippet

# 检查时间格式
snippet timeck "time check 格式"
// const TsFormat1 = "2006-01-02 15:04:05"
if _, err := utils.ParseTimeTsFormat1(${1:req.StartTime}); err != nil {
	logger.Errorf("%s [%s] 时间格式解析出错, ${2:start_time}:%#v, err:", h.RequestID, funcName, $1, err)
	rest.ToFailedJSON(w, h, comm.ERR0006, fmt.Sprintf("[%s] %s", h.RequestID, "$2 parameters err"))
	return
}
endsnippet

####################### map
# types and variables
snippet map "Map type" b
map[${1:keytype}]${2:valtype}
endsnippet

# 判断是否有
snippet ifok "check map key"
if ${5:val}, ${3:ok} := ${1:mapVar}[${2:idx}]; ${4:!}$3 {
	${0:${VISUAL}}
}
endsnippet

snippet mapkey "get map keys"
${1:keys} := make([]${2:int}, 0, len(${3}))
for k := range $3 {
	$1 = append($1, k)
}
endsnippet

snippet mapval "get map vals"
${1:values} := make([]${2:int}, 0, len(${3}))
for _, v := range $3 {
	$1 = append($1, v)
}
endsnippet

snippet fori "for index"
for ${2:i}, _ := range ${1:slice} {
	${3:v} := $1[$2]
	${0:${VISUAL}}
}
endsnippet

########## log

snippet logbug "debug log"
logger.Debugf("%s [${1:%s}] ${2:get basic_info} ${5:err:%v}", ${3:utils.RequestIDFromContext(ctx)}, ${4:funcName},${6:err})
endsnippet

snippet logwn "warnlog"
logger.Warnf("%s [${1:%s}] ${2:get basic_info} ${5:err:%v}", ${3:utils.RequestIDFromContext(ctx)}, ${4:funcName}, ${6:err})
endsnippet

snippet loginfo "infolog"
logger.Infof("%s [${1:%s}] ${2:get basic_info} ${5:err:%v}", ${3:utils.RequestIDFromContext(ctx)}, ${4:funcName}, ${6:err})
endsnippet

snippet logerr "报错log"
logger.Errorf("%s [${1:%s}] ${2:get basic_info} err:%v", ${3:utils.RequestIDFromContext(ctx)}, ${4:funcName}, err)
endsnippet

snippet logtmp "调试 log"
logger.Debugf("[${3:##########}] $1:${2:%#v}", ${1:var})
endsnippet

################## functions
# tracing
snippet spt "opentracing"
funcName := "${1:CurFuncName()}"
sp, ctx := opentracing.StartSpanFromContext(ctx, funcName)
defer sp.Finish()
${0:${VISUAL}}
endsnippet

# tracing
snippet spth "opentracing handle func"
funcName := "${1:CurFuncName()}"
sp := rest.GetRequestTraceSpan(funcName, r)
defer sp.Finish()
ctx := opentracing.ContextWithSpan(r.Context(), sp)
r = r.WithContext(ctx)
h := rest.GetCtxParams(r)
${0:${VISUAL}}
endsnippet

snippet /^main/ "Main function" r
func main() {
	${0:${VISUAL}}
}
endsnippet

snippet /^meth/ "Method" r
func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}${5:type} {
	${0:${VISUAL}}
}
endsnippet

snippet func "Function" b
// $1 ${4:commit}
func ${1:name}(${2:params})${3/(.+)/ /}${3:type} {
	${0:${VISUAL}}
}
endsnippet

snippet funck "Function ctx" b
// $1 ${6:commit}
func ${1:name}(ctx context.Context, h *comm.HandlerInfo, ${4:params} ${5:paramsType}) (${2:returnType}, error) {
	funcName := "$1"
	sp, ctx := opentracing.StartSpanFromContext(ctx, funcName)
	defer sp.Finish()

	var ${3:resp} $2

	${0:${VISUAL}}
	return $3, nil
}
endsnippet

snippet funcclass "Function ctx" b
// $3 ${8:commit}
func (${1:c} ${2:*ClassType}) ${3:name}(ctx context.Context, h *comm.HandlerInfo, ${5:params} ${6:paramsType}) (${4:returnType}, error) {
	funcName := "$3"
	sp, ctx := opentracing.StartSpanFromContext(ctx, funcName)
	defer sp.Finish()

	var ${7:resp} $4

	${0:${VISUAL}}
	return $7, nil
}
endsnippet

snippet funch "HTTP handler" b
// Handle$1 ${10:commit}
func Handle${1:Name}(w http.ResponseWriter, r *http.Request) {
	funcName := "$1"
	sp := rest.GetRequestTraceSpan(funcName, r)
	defer sp.Finish()
	ctx := opentracing.ContextWithSpan(r.Context(), sp)
	r = r.WithContext(ctx)
	h := rest.GetCtxParams(r)
	vars    := mux.Vars(r)
	${0:${VISUAL}}
	// path
	${2:cityId}, err := strconv.ParseInt(vars["${3:city_id}"], 10, 64)
	if err != nil {
		logger.Warnf("%s [%s] 参数 $3 有误, err:%v", h.RequestID, funcName, err)
		rest.ToFailedJSON(w, h, comm.ERR0006, common.GetInvalidParmErr(h))
		return
	}

	// query
	var ${4:req} = &${5:CityActivityReq}{}
	decoder := schema.NewDecoder()
	decoder.IgnoreUnknownKeys(true)
	if err := decoder.Decode($4, r.URL.Query()); err != nil {
		logger.Warnf("%s [%s] 参数有误, err:%v", h.RequestID, funcName, err)
		rest.ToFailedJSON(w, h, comm.ERR0006, common.GetInvalidParmErr(h))
		return
	}

	// header
	// language := h.Lang

	if resp, err := $1(ctx, h, ${6:params}); err != nil {
		logger.Errorf("%s [%s]  ${7:msg} 出错, err:%v", h.RequestID, funcName, err)
		rest.ToFailedJSON(w, h, comm.ERR0001, "Failed to $7")
		return
	} else {
		rest.ToJSON(w, h, resp)
	}
}
// $1 $10
func $1(ctx context.Context, h *comm.HandlerInfo, ${12:params}) (${11:returnType}, error) {
	funcName := "$1"
	sp, ctx := opentracing.StartSpanFromContext(ctx, funcName)
	defer sp.Finish()

	var ${13:resp} $9

	return $13, nil
}
endsnippet

snippet errparam "参数错误"
logger.Warnf("%s [${1:HandleQueryStationI18n}] parameters err. ${2:city_id}:%s", ${3:h.RequestID}, ${4:cityId})
rest.ToFailedJSON(w, h, comm.ERR0006, "parameters err")
return
endsnippet

snippet paramid "解析整数 ID"
${2:activityId}Param := r.FormValue("${1:activity_id}")
$2, err := strconv.ParseInt($2Param, 10, 64)
if err != nil || $2 <=0 {
	logger.Errorf("%s [%s] 参数错误, $1:%v, err:%v", h.RequestID, funcName, $2Param, err)
	rest.ToFailedJSON(w, h, comm.ERR0006, fmt.Sprintf("param err, $1:%v", $2Param))
	return
}
endsnippet

snippet paramids "解析整数 ID 列表"
${2:activityIds}Param := r.FormValue("${1:activity_id_list}")
$2 := make([]int64, 0)
for _, v := range strings.Split($2Param, ",") {
	id, err := strconv.ParseInt(v, 10, 64)
	if err != nil || id <=0 {
		logger.Errorf("%s [%s] 参数错误, $1:%v, err:%v", h.RequestID, funcName, $2Param, err)
		rest.ToFailedJSON(w, h, comm.ERR0006, fmt.Sprintf("param err, $1:%v", $2Param))
		return
	}
}
endsnippet

#################### url 请求与转发
snippet urlget "URL Get 调用"
var ${1:data} = ${2:make([]*CityNews, 0)}
queryURL := fmt.Sprintf("%s${3:/v1/prodbasesrv/city/%d/basic_info}", ${4:conf.Conf.ProdBaseHost} ${5:, cityId})
// 基础服务 prorest, 三端共用服 apprest
if err := ${6:apprest}.GetAndParseResult(ctx, h, queryURL, &$1); err != nil {
	logger.Errorf("%s [${7:GetCityTravelTipsByDB}] ${8:get basic_info} err:%v", h.RequestID, ${9: }err)
	return ${10:nil, err}
}
${0:${VISUAL}}
endsnippet

snippet urlpost "URL Post 调用"
${1:var req nearbyRequest}
var ${2:resp} = ${3:prodbaseQueryResponse}
queryURL := fmt.Sprintf("%s${4:/v1/prodbasesrv/fnb/nearby}", ${4:conf.Conf.ProdBaseHost} ${6:, params})
// 基础服务 prorest, 三端共用服 apprest
if err := ${7:apprest}.PostAndParseResult(ctx, h, queryURL, ${8:req}, &$2); err != nil {
	logger.Errorf("%s [${9:GetCityTravelTipsByDB}] ${10:get basic_info} err:%v", utils.RequestIDFromContext(ctx), ${11: }err)
	return ${12:nil, err}
}
${0:${VISUAL}}
endsnippet

snippet proxy "转发 url"
${1:dstUrl} := fmt.Sprintf("%s${2:/v1/prodbasesrv/cities/%s/publish}", conf.Conf.ProdBaseHost)
$1 = strings.Replace($1, ${4:"path_or_query"}, ${5:var}, 1)
${0:${VISUAL}}
// 基础服务 prorest, 三端共用服 apprest
${3:prorest}.Proxy(${6:w}, ${7:r}, $1)
endsnippet

# post body
snippet reqpost "postunmasrshal"
${1:req} := ${2:smsConfirmRequest}{}
if err := utils.ParseBodyAndUnmarshal(r, &$1); err != nil {
	logger.Error(${3:h}.RequestID, " 解析出错, err:", err)
	rest.ToFailedJSON(w, $3, comm.ERR0006, ${5:fmt.Sprintf("[%s] %s", $3.RequestID, "${4:parameters err}")})
	return
}
${0:${VISUAL}}
endsnippet

snippet reqget "get query request param"
// query
var ${1:req} = &${2:CityActivityReq}{}
decoder := schema.NewDecoder()
decoder.IgnoreUnknownKeys(true)
if err := decoder.Decode($1, r.URL.Query()); err != nil {
	logger.Error(${3:h}.RequestID, "[Handle${4:Name}}] err:", err)
	rest.ToFailedJSON(w, h, comm.ERR0006, ${5:common.GetInvalidParmErr(h)})
	return
}
${0:${VISUAL}}
endsnippet

############ 数据库操作
snippet sqlx "sqlx.In"
querySql, args, err := sqlx.In(${5:query}, ${1:lang, actIDs})
if err != nil {
	return nil, err
}
logger.Debugf("%s [${6:CityDetailRds.FetchList}] querySql:%s, args:%v", ${7:utils.RequestIDFromContext(ctx)} ${8:}, querySql, args)
var ${2:data} = make([]*${3:Category}, 0)
// productdb.ReadDB, projectkdb.LibsMyDB.GetSqlxDB(), rds.LibsMyDB.GetSqlxDB()
if err := ${4:rds.LibsMyDB.GetSqlxDB()}.SelectContext(ctx, &$2, querySql, args...); err != nil {
	return nil, err
}
if ${9:len(data) == 0} ${10:||} ${11:data == nil}{
	return nil, errors.New(fmt.Sprintf("%s [$6] no data", $7 $8))
}
${0:${VISUAL}}
endsnippet

# sqlx
snippet tx "sqlx.Tx"
tx, err := ${1:projectkdb.ProKDB}.Beginx()
if err != nil {
	return ${2:err}
}
defer tx.Rollback()
${0:${VISUAL}}
if err := ${3:smsdb.InsertUserFraud}(${4:ctx}, ${5:tx}, ${6:userFraud}); err != nil {
	return $2
}
return ${7:tx.Commit()}
endsnippet

############## 增删改查
## 检查db
snippet dbck "db check"
if rds.${1:LibsMyDB} == nil {
	return nil, errors.New(fmt.Sprintf("%s [${2:CityDetailRds.Fetch}] ${3:db} is nil", ${4:utils.RequestIDFromContext(ctx)} ${5:}))
}
endsnippet


## 插入
snippet dbinsf "insert func"
// Insert$1 ${3: }
func Insert${1:I18nHashMd5}(ctx context.Context, tx *sqlx.Tx, ctg *${2:I18nHashMd5}) (int64, error) {
	insertSql := \`
			INSERT INTO bas_hashmd5_i18n(
				hash_md5,
				content_res)
			VALUES (
				:hash_md5,
				:content_res);
			\`

	id, err := prodbcomm.NamedExecInsert(ctx, tx, insertSql, ctg)
	if err != nil {
		return -1, err
	}
	ctg.Id = id
	return id, nil
}
endsnippet
## 插入
snippet dbins "insert"
id, err := ${3:prodbcomm}.NamedExecInsert(ctx, tx, ${1:insertSql}, ${2:data})
if err != nil {
	return -1, err
}
$2.Id = id
endsnippet
## 插入
snippet dbinsu "insert or update"
INSERT INTO ${1:city_detail} (
	${2:city_id},
	${3:language},
	${4:name}
) VALUES (
	:$2,
	:$3,
	:$4,
) ON DUPLICATE KEY UPDATE
	$4 = :$4
;
endsnippet


## 更新
snippet dbupdf "update func"
// Update$1 ${3: }
func Update${1:I18nHashMd5}(ctx context.Context, tx *sqlx.Tx, ctg *${2:I18nHashMd5}) error {
	updateSql := \`
			UPDATE bas_hashmd5_i18n
			SET
				flag			= :flag,
				hash_md5		= :hash_md5,
				content_res		= :content_res
			WHERE id = :id;
			\`

	return prodbcomm.NamedExecUpdate(ctx, tx, updateSql, ctg)
}
endsnippet
## 更新
snippet dbupd "update"
${3:prodbcomm}.NamedExecUpdate(ctx, tx, ${1:updateSql}, ${2:data})
endsnippet


## 查找
snippet dbself "select func"
// Get$1 ${6: }
func Get${1:I18nHashMd5ByMd5}(ctx context.Context, ${2:hashMd5s} []${3:string}) ([]*${4:I18nHashMd5}, error) {
	query := \`
			SELECT
				id,
				hash_md5,
				content_res
			FROM bas_hashmd5_i18n
			WHERE flag = 0 AND hash_md5 IN (?);
			\`

	ctgs := make([]*$4, 0)
	// 这里需要为：*sqlx.DB 类型的db, productdb 为 productdb.LibsMyDB.GetSqlxDB(), projectkdb 为 projectkdb.LibsMyDB.GetSqlxDB()
	err := prodbcomm.Select(ctx, ${5:productdb}.LibsMyDB.GetSqlxDB(), &ctgs, []string{}, query, $2)
	return ctgs, err
}
endsnippet
## 查找
snippet dbsel "select"
${2:data} := make([]${1:*int64}, 0)
// 这里需要为：*sqlx.DB 类型的db, productdb 为 productdb.LibsMyDB.GetSqlxDB(), projectkdb 为 projectkdb.LibsMyDB.GetSqlxDB()
if err := prodbcomm.Select(ctx, ${5:productdb}.LibsMyDB.GetSqlxDB(), &$2, []string{}, query, ${3:args}); err != nil{
	return ${4:nil, err}
}
endsnippet

## 查找
snippet dbqu "query"
${2:data} := make([]${1:*int64}, 0)
// 这里需要为：*sqlx.DB 类型的db, productdb 为 productdb.LibsMyDB.GetSqlxDB(), projectkdb 为 projectkdb.LibsMyDB.GetSqlxDB()
if err := prodbcomm.Query(ctx, ${5:productdb}.LibsMyDB.GetSqlxDB(), &$2, query, ${3:args}); err != nil{
	return ${4:nil, err}
}
endsnippet

## 查找
snippet dbscan "db scan vars"
var ${1:dest} ${2:int64}
${6:dbRow} := ${5:db.RWKdb}.QueryRow(${3:query}, ${4:arg})
if err := $6.Scan(&$1); err != nil {
	return ${7:nil, err}
}
endsnippet

## datasrv/apis import
snippet dbapis
dbapis "klook.com/datasrv/apis"
endsnippet

## 切割list分批处理
snippet splitls "splitls"
${1:reviewInfos} := make(${2:[]*review.DBReviewIdInfo, 0})
${3:activityIds} := make([]${4:int64}, 0)
${5:length} := len(${6:activityIdsList})
// 根据 $3 获取 $1
for idx, id := range $6 {
	$3 = append($3, id)
	nextIdx := idx + 1
	if nextIdx%${7:prodbcomm.MaxSqlInIdCount} == 0 || nextIdx >= length {
		slicesItems, err := ${8:reviews.GetReviewIDListByActIDList}(ctx ${9:, } $3 ${10:, language, page, limit})
		if err != nil {
			logger.Warnf("%s [%s] ${10:err:%v}", ${11:requestID}, ${12:funcName} ${13:, err})
			continue
			// return nil, err
		}
		$1 = append($1, slicesItems...)

		$3 = make([]$4, 0)
	}
}
endsnippet

## slicesIds
## 切割list分批处理
snippet slicesls "切割list分批处理"
// procomm.UniqueInt64Slice(&$2)
${1:length} := len(${2:activityIdsList})
// 根据 $2 获取 $3
${3:reviewInfos} := make([]${4:*review.DBReviewIdInfo}, 0)
var ${5:nextIdx} int
for ${15:idx} := 0; $15 < $1; $15 = $5 {
	$5 = $15 + ${6:prodbcomm.MaxSqlInIdCount}
	if $5 > $1{
		$5 = $1
	}
	${7:activityIds}:= $2[$15:$5]
	${8:slicesItems}, err := ${9:reviews.GetReviewIDListByActIDList}(ctx, $7, ${10:language, page, limit})
	if err != nil {
		logger.Warnf("%s [%s] ${11:err:%v}", ${12:requestID}, ${13:funcName} ${14:, err})
		continue
	}
	$3 = append($3, $8...)
}
endsnippet


# test function
snippet testf "func Test_XYZ(t *testing.T) { ... }"

func Test_$1(t *testing.T) {
	funcName := "$1"
	logger.MockLogger(t)
	// projectkdb , productdb
	${2:db}.MockDB(t, "${3:../../service.conf}")
	// rds.MockDBProjctKDB 或 rds.MockDBProductDB
	// rds.${4:MockDBProjctKDB}(t)
	${5:ctx := context.Background()}
	${6:lang := locale.EN_US}
	${0:${VISUAL}}
	resp, ${7: } err := ${9: } ${1:GetActivityCardList}${8:(param)}
	if err != nil {
		t.Errorf("[%s] err:%s", funcName, err)
	}

	${10:if err := rds.WriteTestOutToFile(resp, funcName, "", true); err != nil {
		t.Errorf("[%s] WriteTestOutToFil err:%s", funcName, err)
	}}

	${11:logger.Debugf("[##########] resp:%#v", resp)}
	t.Logf("[%s] Pass", funcName)
}
endsnippet

# benchmark function
snippet benchf "func Benchmark_XYZ(t *testing.T) { ... }"
func Benchmark_$1(b *testing.B) {
	${2:redisdb}.MockRedisForBench(b, "${3:../../service.conf}")
	// projectkdb , productdb
	${4:db}.MockDB(t, "${3:../../service.conf}")
	for i := 0; i < b.N; i++ {
		${1:GetYSimHome}(context.Background(), h, userId)
	}
}
endsnippet


snippet sortint "SortInt64s"
${1:procomm}.SortInt64s(${2:cityIds})
endsnippet

snippet uniqint "UniqueInt64Slice"
${1:procomm}.UniqueInt64Slice(&${2:slice})
endsnippet

snippet uniqstr "UniqueStringSlice"
${1:procomm}.UniqueStringSlice(&${2:slice})
endsnippet

snippet doc "文档"
/**************************************************************
Func: ${1:Func}
Req : ${2:req}
Resp: ${3:resp}
Desc: ${0:${VISUAL}}
**************************************************************/
endsnippet

snippet sortst "sort struct"
type ${2:ByPriority2} []*${1:ContentThemesStructV2}

func (a $2) Len() int           { return len(a) }
func (a $2) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a $2) Less(i, j int) bool { return a[i]${3:.Priority} < a[j]$3}
endsnippet


############ go-swagger ##############
snippet swagget "go-swagger-get"
////////////////////////////////////////////////////////////////////////////////////
// start api doc defination GET
////////////////////////////////////////////////////////////////////////////////////
// swagger:parameters ${1:queryOpertionId}
type $1Request struct {
	// ${8:语言}
	// Required: true
	// in: ${7:query}
	${5:Language} ${6:string}
	// ${12:vars, 逗号分隔，总数不能大于 100}
	// Required: true
	// in: ${11:path}
	${9:PathVar} ${10:string}
}

// swagger:response
type $1ResponseWrapper struct {
	// in: body
	Body struct {
		apis.KlAPIResponse
		Result ${13:[]int64} `json:"result"`
	}
}
${0:${VISUAL}}
// swagger:route GET ${4:/servicesrv/ping/{path_var}} ${2:tag} $1
//
// ${3:route desc}.
//
//
//		Responses:
//		  200: $1Response
endsnippet

snippet swagpost "go-swagger-post"
////////////////////////////////////////////////////////////////////////////////////
// start api doc defination POST
////////////////////////////////////////////////////////////////////////////////////
type $5 struct{
${0:${VISUAL}}
}

// swagger:parameters ${1:postOpertionId}
type $1Request struct {
	// in: body
	Body ${5:bodyStruct}
}

// swagger:response
type $1ResponseWrapper struct {
	// in: body
	Body struct {
		apis.KlAPIResponse
		Result ${6:[]int64} `json:"result"`
	}
}

// swagger:route POST ${4:/servicesrv/ping/{path_var}} ${2:tag} $1
//
// ${3:route desc}.
//
//
//		Responses:
//		  200: $1Response
endsnippet

############ TODO ##############
snippet todo "TODO 注释"
// TODO: ${1:description}
endsnippet

snippet depr "废弃注释"
// Deprecated ${1:已废弃, 不建议使用此函数/变量，请使用替代函数/变量}
endsnippet

#################################
snippet gorun "go 协程"
var ctxDup = utils.ContextDup(ctx)
go utils.HandlePanic(ctxDup, func() {
	${1:funCall()}
})()
endsnippet
