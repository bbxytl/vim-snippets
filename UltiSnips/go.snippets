# Snippets for Go

priority -50

# when to abbriviate and when not?
# b doesn't work here, because it ignores whitespace
# optional local name?
snippet /^import/ "Import declaration" r
import (
	"${1:package}"
)
endsnippet

snippet /^package/ "Package declaration" r
// Package $1 provides ...
package ${1:main}
endsnippet

# Mostly converted from: https://github.com/AlanQuatermain/go-tmbundle
snippet /^cons/ "Constants declaration" r
const (
	${1:constant}${2/(.+)/ /}${2:type} = ${0:value}
)
endsnippet

snippet /^con/ "Constant declaration" r
const ${1:name}${2/(.+)/ /}${2:type} = ${0:value}
endsnippet

snippet iota "Iota constant generator" b
const (
	${1:constant}${2/(.+)/ /}${2:type} = iota
)
endsnippet

snippet struct "Struct declaration" b
type ${1:Struct} struct {
	${0:${VISUAL}}
}
endsnippet

snippet interface "Interface declaration" b
type ${1:Interface} interface {
	${0:${VISUAL}}
}
endsnippet

snippet if "If statement" b
if ${1:condition}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet switch "Switch statement" b
switch ${1:expression}${1/(.+)/ /}{
case$0
}
endsnippet

snippet : "Variable declaration :=" b
${1:name} := ${0:value}
endsnippet

snippet var "Variable declaration" b
var ${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value}}
endsnippet

snippet vars "Variables declaration" b
var (
	${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value} }
)
endsnippet

snippet json "JSON field"
\`json:"${1:displayName}"\`
endsnippet

snippet jsonomi "JSON omitempty"
omitempty
endsnippet

snippet schema "schema field"
\`schema:"${1:displayName}"\`
endsnippet

# vim:ft=snippets:

# error handling
snippet err "Basic error handling" b
if err != nil {
	log.${1:Fatal}(err)
}
endsnippet


# redis
snippet cc "redisGetSetV3" b
	${0:${VISUAL}}libsrdb "klook.libs/db/redisdb"
	var (
		response = ${1:responseType}
		cacheKey = fmt.Sprintf("%s:${4:cacheKey}", redisdb${5:.CacheTagName}, ${6:cacheKeyParams})
		err error
	)

	f := func(timeout bool) error {
		if timeout {
			return nil
		}
		// get from cache
		if err = redisdb.Get(cacheKey, &response); err != nil {
			// query from http
			if response, err = ${2:funbyDB}(ctx, ${3:params}); err != nil {
				return err
			}
			// save to cache
			if err = redisdb.Set(cacheKey, response, redisdb${7:.DefaultExpiresTime}); err != nil {
				logger.Errorf("%s key:%s err:%s", utils.RequestIDFromContext(ctx), cacheKey, err)
			}
		}
		return nil
	}
	// 加锁更新redis缓存，避免缓存失效对mysql造成冲击
	// 	libsrdb "klook.libs/db/redisdb"
	return response, libsrdb.NewRedislock(redisdb.CacheDB, redisdb.LockExpireTime, redisdb.LockTries, redisdb.LockDelayTime).GetSetV3(cacheKey, f)
endsnippet

# Fmt Sprintf
snippet fsf "fmt.Sprintf(...)"
fmt.Sprintf("${1:${VISUAL}}: %+v\n", $1)
endsnippet

# Fmt Println debug
snippet fsn "fmt.Sprintln(...)"
fmt.Sprintln("${1:${VISUAL}}")
endsnippet

# RealLang
snippet lang "language"
${3:lang} ${1::}= prolocale.RealLang(${2:h.Lang})
${0:${VISUAL}}
endsnippet

# append
snippet app "append"
${1:list} = append($1, ${2:item})
${0:${VISUAL}}
endsnippet

#################### 时间
# timeAdd
snippet timeadd "time.Add"
// 一天后
${1:startTime} := time.Now()${2:.UTC().}AddDate(0, 0, ${5:1}).Format(${3:utils.TsFormat1})
${4:endTime} := time.Now().UTC().Format($3)
${0:${VISUAL}}
// 北京时间 12小时前
$1 := time.Now()$2Add(${6:8} * time.Hour).Add(${7:-12} * time.Hour).Format($3)
// 北京时间, utc 8小时后
$4 := time.Now()$2Add($6 * time.Hour).Format($3)
endsnippet

snippet timefmt "time.Parse"
${0:${VISUAL}}
var ${1:timeStrTo} string
if ${2:tt}, err := time.Parse("${3:2006-01-02 15:04:05}", ${4:timeStrFrom}); err == nil {
	$1 = $2.Format("${5:2006-01-02T15:04:05Z}")
}
endsnippet

####################### map
# types and variables
snippet map "Map type" b
map[${1:keytype}]${2:valtype}
endsnippet

# 判断是否有
snippet mapok "check map key"
if _, ${1:ok} := ${2:mapVar}[${3:idx}]; ${4:!}$1 {
	${5:val} := $2[$3]
	${0:${VISUAL}}
}
endsnippet

snippet mapkey "get map keys"
${1:keys} := make([]${2:int}, 0, len(${3}))
for k := range $3 {
	$1 = append($1, k)
}
${0:${VISUAL}}
endsnippet

snippet mapval "get map vals"
${1:values} := make([]${2:int}, 0, len(${3}))
for _, v := range $3 {
	$1 = append($1, v)
}
${0:${VISUAL}}
endsnippet

snippet errlog "报错log"
logger.Errorf("%s [${1:GetCityTravelTipsByDB}] ${2:get basic_info} err:%s", utils.RequestIDFromContext(ctx), err.Error())
${0:${VISUAL}}
endsnippet

################## functions
# tracing
snippet spt "opentracing"
sp, ctx := opentracing.StartSpanFromContext(ctx, "${1:QueryEmailAndIP}")
defer sp.Finish()
${0:${VISUAL}}
endsnippet

snippet /^main/ "Main function" r
func main() {
	${0:${VISUAL}}
}
endsnippet

snippet /^meth/ "Method" r
func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}${5:type} {
	${0:${VISUAL}}
}
endsnippet

snippet func "Function" b
// $1 ${4:commit}
func ${1:name}(${2:params})${3/(.+)/ /}${3:type} {
	${0:${VISUAL}}
}
endsnippet

snippet funck "Function ctx" b
// $1 ${6:commit}
func ${1:name}(ctx context.Context, h *comm.HandlerInfo, ${4:params} ${5:paramsType}) (${2:returnType}, error) {
	sp, ctx := opentracing.StartSpanFromContext(ctx, "$1")
	defer sp.Finish()

	var (
		${3:resp} $2
		err error
	)

	${0:${VISUAL}}
	return $3, err
}
endsnippet

snippet funch "HTTP handler" b
// Handle$1 ${8:commit}
func Handle${1:Name}(w http.ResponseWriter, r *http.Request) {
	sp := rest.GetRequestTraceSpan("Handle$1", r)
	defer sp.Finish()
	ctx := opentracing.ContextWithSpan(r.Context(), sp)
	r = r.WithContext(ctx)
	h := rest.GetCtxParams(r)
	vars    := mux.Vars(r)
	${0:${VISUAL}}
	// path
	${2:cityId}, err := strconv.ParseInt(vars["${3:city_id}"], 10, 64)
	if err != nil {
		logger.Warn(h.RequestID, "[Handle$1] 参数 $3 有误, err=", err.Error())
		rest.ToFailedJSON(w, h, comm.ERR0006, common.GetInvalidParmErr(h))
		return
	}

	// query
	var ${4:req} = &${5:CityActivityReq}{}
	decoder := schema.NewDecoder()
	decoder.IgnoreUnknownKeys(true)
	if err := decoder.Decode($4, r.URL.Query()); err != nil {
		logger.Error(h.RequestID,"[Handle$1] err:", err)
		rest.ToFailedJSON(w, h, comm.ERR0006, common.GetInvalidParmErr(h))
		return
	}

	// header
	// language := h.Lang

	if resp, err := $1(ctx, h, ${6:params}); err != nil {
		logger.Error(h.RequestID, "[Handle$1] ${7:msg} 出错, err=", err.Error())
		rest.ToFailedJSON(w, h, comm.ERR0001, "Failed to $7")
		return
	} else {
		rest.ToJSON(w, h, resp)
	}
}
// $1 $8
func $1(ctx context.Context, h *comm.HandlerInfo, ${10:params}) (${9:returnType}, error) {
	sp, ctx := opentracing.StartSpanFromContext(ctx, "$1")
	defer sp.Finish()

	var (
		${11:resp} $9
		err error
	)

	return $11, err
}
endsnippet

snippet errparam "参数错误"
logger.Warnf("%s [${1:HandleQueryStationI18n}] parameters err. ${2:city_id}:%s", ${3:h.RequestID}, ${4:cityId})
rest.ToFailedJSON(w, h, comm.ERR0006, "parameters err")
return
endsnippet

#################### url 请求与转发
snippet urlget ""
var ${1:data} = ${2:make([]*CityNews, 0)}
queryURL := fmt.Sprintf("%s${3:/v1/prodbasesrv/city/%d/basic_info}", ${4:conf.Conf.ProdBaseHost} ${5:, cityId})
// 基础服务 prorest, 三端共用服 apprest
if err := ${6:apprest}.GetAndParseResult(ctx, h, queryURL, &$1); err != nil {
	logger.Errorf("%s [${7:GetCityTravelTipsByDB}] ${8:get basic_info} err:%s", h.RequestID, ${9: }err.Error())
	return ${10:nil, err}
}
${0:${VISUAL}}
endsnippet

snippet urlpost ""
${1:var req nearbyRequest}
var ${2:resp} = ${3:prodbaseQueryResponse}
queryURL := fmt.Sprintf("%s${4:/v1/prodbasesrv/fnb/nearby}", ${4:conf.Conf.ProdBaseHost} ${6:, params})
// 基础服务 prorest, 三端共用服 apprest
if err := ${7:apprest}.PostAndParseResult(ctx, h, queryURL, ${8:req}, &$2); err != nil {
	logger.Errorf("%s [${9:GetCityTravelTipsByDB}] ${10:get basic_info} err:%s", utils.RequestIDFromContext(ctx), ${11: }err.Error())
	return ${12:nil, err}
}
${0:${VISUAL}}
endsnippet

snippet proxy "转发 url"
${1:dstUrl} := fmt.Sprintf("%s${2:/v1/prodbasesrv/cities/%s/publish}", conf.Conf.ProdBaseHost)
$1 = strings.Replace($1, ${4:"path_or_query"}, ${5:var}, 1)
${0:${VISUAL}}
// 基础服务 prorest, 三端共用服 apprest
${3:prorest}.Proxy(${6:w}, ${7:r}, $1)
endsnippet

# post body
snippet reqpost "postunmasrshal"
${1:req} := ${2:smsConfirmRequest}{}
if err := utils.ParseBodyAndUnmarshal(r, &$1); err != nil {
	logger.Error(${3:h}.RequestID, " 解析出错, err:", err.Error())
	rest.ToFailedJSON(w, $3, comm.ERR0006, ${5:fmt.Sprintf("[%s] %s", $3.RequestID, "${4:parameters err}")})
	return
}
${0:${VISUAL}}
endsnippet

snippet reqget "get query request param"
// query
var ${1:req} = &${2:CityActivityReq}{}
decoder := schema.NewDecoder()
decoder.IgnoreUnknownKeys(true)
if err := decoder.Decode($1, r.URL.Query()); err != nil {
	logger.Error(${3:h}.RequestID, "[Handle${4:Name}}] err:", err)
	rest.ToFailedJSON(w, h, comm.ERR0006, ${5:common.GetInvalidParmErr(h)})
	return
}
${0:${VISUAL}}
endsnippet

############ 数据库操作
snippet sqlx "sqlx.In"
querySql, args, err := sqlx.In(${5:query}, ${1:lang, actIDs})
if err != nil {
	return nil, err
}
var ${2:data} = make([]*${3:Category}, 0)
// productdb.ReadDB, projectkdb.LibsMyDB.GetSqlxDB()
if err := ${4:productdb.ReadDB}.SelectContext(ctx, &$2, querySql, args...); err != nil {
	return nil, err
}
${0:${VISUAL}}
endsnippet

# sqlx
snippet tx "sqlx.Tx"
tx, err := ${1:projectkdb.ProKDB}.Beginx()
if err != nil {
	return ${2:err}
}
defer tx.Rollback()
${0:${VISUAL}}
if err := ${3:smsdb.InsertUserFraud}(${4:ctx}, ${5:tx}, ${6:userFraud}); err != nil {
	return $2
}
return ${7:tx.Commit()}
endsnippet

############## 增删改查
## 插入
snippet dbins "insert"
// Insert$1 ${3: }
func Insert${1:I18nHashMd5}(ctx context.Context, tx *sqlx.Tx, ctg *${2:I18nHashMd5}) (int64, error) {
	insertSql := \`
			INSERT INTO bas_hashmd5_i18n(
				hash_md5,
				content_res)
			VALUES (
				:hash_md5,
				:content_res);
			\`

	id, err := prodbcomm.NamedExecInsert(ctx, tx, insertSql, ctg)
	if err != nil {
		return -1, err
	}
	ctg.Id = id
	return id, nil
}
endsnippet

## 更新
snippet dbupd "update"
// Update$1 ${3: }
func Update${1:I18nHashMd5}(ctx context.Context, tx *sqlx.Tx, ctg *${2:I18nHashMd5}) error {
	updateSql := \`
			UPDATE bas_hashmd5_i18n
			SET
				flag			= :flag,
				hash_md5		= :hash_md5,
				content_res		= :content_res
			WHERE id = :id;
			\`

	return prodbcomm.NamedExecUpdate(ctx, tx, updateSql, ctg)
}
endsnippet

## 查找
snippet dbsel "select"
// Get$1 ${6: }
func Get${1:I18nHashMd5ByMd5}(ctx context.Context, ${2:hashMd5s} []${3:string}) ([]*${4:I18nHashMd5}, error) {
	query := \`
			SELECT
				id,
				hash_md5,
				content_res
			FROM bas_hashmd5_i18n
			WHERE flag = 0 AND hash_md5 IN (?);
			\`

	ctgs := make([]*$4, 0)
	// 这里需要为：*sqlx.DB 类型的db, productdb 为 productdb.LibsMyDB.GetSqlxDB(), projectkdb 为 projectkdb.LibsMyDB.GetSqlxDB()
	err := prodbcomm.Select(ctx, ${5:productdb}.LibsMyDB.GetSqlxDB(), &ctgs, []string{}, query, $2)
	return ctgs, err
}
endsnippet
